"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwaggerExplorer = void 0;
const core_1 = require("@midwayjs/core");
const constants_1 = require("./constants");
const documentBuilder_1 = require("./documentBuilder");
const _1 = require(".");
let SwaggerExplorer = class SwaggerExplorer {
    constructor() {
        this.documentBuilder = new documentBuilder_1.DocumentBuilder();
    }
    async init() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _2, _3, _4, _5;
        this.documentBuilder.setTitle(this.swaggerConfig.title);
        this.documentBuilder.setVersion(this.swaggerConfig.version);
        this.documentBuilder.setDescription(this.swaggerConfig.description);
        if (((_a = this.swaggerConfig) === null || _a === void 0 ? void 0 : _a.contact) &&
            typeof ((_b = this.swaggerConfig) === null || _b === void 0 ? void 0 : _b.contact) === 'object') {
            this.documentBuilder.setContact((_d = (_c = this.swaggerConfig) === null || _c === void 0 ? void 0 : _c.contact) === null || _d === void 0 ? void 0 : _d.name, (_f = (_e = this.swaggerConfig) === null || _e === void 0 ? void 0 : _e.contact) === null || _f === void 0 ? void 0 : _f.url, (_h = (_g = this.swaggerConfig) === null || _g === void 0 ? void 0 : _g.contact) === null || _h === void 0 ? void 0 : _h.email);
        }
        if (((_j = this.swaggerConfig) === null || _j === void 0 ? void 0 : _j.license) &&
            typeof ((_k = this.swaggerConfig) === null || _k === void 0 ? void 0 : _k.license) === 'object') {
            this.documentBuilder.setLicense((_m = (_l = this.swaggerConfig) === null || _l === void 0 ? void 0 : _l.license) === null || _m === void 0 ? void 0 : _m.name, (_p = (_o = this.swaggerConfig) === null || _o === void 0 ? void 0 : _o.license) === null || _p === void 0 ? void 0 : _p.url);
        }
        if (this.swaggerConfig.termsOfService) {
            this.documentBuilder.setTermsOfService(this.swaggerConfig.termsOfService);
        }
        if (((_q = this.swaggerConfig) === null || _q === void 0 ? void 0 : _q.externalDocs) &&
            typeof ((_r = this.swaggerConfig) === null || _r === void 0 ? void 0 : _r.externalDocs) === 'object') {
            this.documentBuilder.setExternalDoc((_t = (_s = this.swaggerConfig) === null || _s === void 0 ? void 0 : _s.externalDocs) === null || _t === void 0 ? void 0 : _t.description, (_v = (_u = this.swaggerConfig) === null || _u === void 0 ? void 0 : _u.externalDocs) === null || _v === void 0 ? void 0 : _v.url);
        }
        if (((_w = this.swaggerConfig) === null || _w === void 0 ? void 0 : _w.servers) &&
            Array.isArray((_x = this.swaggerConfig) === null || _x === void 0 ? void 0 : _x.servers)) {
            for (const serv of (_y = this.swaggerConfig) === null || _y === void 0 ? void 0 : _y.servers) {
                this.documentBuilder.addServer(serv === null || serv === void 0 ? void 0 : serv.url, serv === null || serv === void 0 ? void 0 : serv.description, serv === null || serv === void 0 ? void 0 : serv.variables);
            }
        }
        if (((_z = this.swaggerConfig) === null || _z === void 0 ? void 0 : _z.tags) && Array.isArray((_0 = this.swaggerConfig) === null || _0 === void 0 ? void 0 : _0.tags)) {
            for (const t of (_2 = this.swaggerConfig) === null || _2 === void 0 ? void 0 : _2.tags) {
                this.documentBuilder.addTag(t.name, t.description, t.externalDocs);
            }
        }
        // 设置 auth 类型
        if (Array.isArray((_3 = this.swaggerConfig) === null || _3 === void 0 ? void 0 : _3.auth)) {
            for (const a of (_4 = this.swaggerConfig) === null || _4 === void 0 ? void 0 : _4.auth) {
                this.setAuth(a);
            }
        }
        else {
            this.setAuth((_5 = this.swaggerConfig) === null || _5 === void 0 ? void 0 : _5.auth);
        }
    }
    addGlobalPrefix(prefix) {
        if (!prefix) {
            return;
        }
        this.documentBuilder.addServer(prefix);
    }
    scanApp() {
        var _a;
        const routes = (0, core_1.listModule)(core_1.CONTROLLER_KEY);
        for (const route of routes) {
            this.generatePath(route);
        }
        if ((_a = this.swaggerConfig) === null || _a === void 0 ? void 0 : _a.tagSortable) {
            this.documentBuilder.sortTags();
        }
    }
    getData() {
        return this.documentBuilder.build();
    }
    generatePath(target) {
        this.parseExtraModel(target);
        const metaForMethods = (0, core_1.getClassMetadata)(core_1.INJECT_CUSTOM_METHOD, target) || [];
        const exs = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_EXCLUDE_CONTROLLER);
        if (exs[0]) {
            return;
        }
        const metaForParams = (0, core_1.getClassMetadata)(core_1.INJECT_CUSTOM_PARAM, target) || [];
        const controllerOption = (0, core_1.getClassMetadata)(core_1.CONTROLLER_KEY, target);
        const prefix = controllerOption.prefix;
        const tags = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_TAGS);
        let strTags = [];
        if (tags.length > 0) {
            for (const t of tags) {
                // 这里 metadata => string[]
                strTags = strTags.concat(t.metadata);
                this.documentBuilder.addTag(t.metadata);
            }
        }
        else {
            const tag = { name: '', description: '' };
            if (prefix !== '/') {
                tag.name =
                    (controllerOption === null || controllerOption === void 0 ? void 0 : controllerOption.routerOptions.tagName) ||
                        (/^\//.test(prefix) ? prefix.split('/')[1] : prefix);
                tag.description =
                    (controllerOption === null || controllerOption === void 0 ? void 0 : controllerOption.routerOptions.description) || tag.name;
            }
            else {
                tag.name = controllerOption === null || controllerOption === void 0 ? void 0 : controllerOption.routerOptions.tagName;
                tag.description =
                    (controllerOption === null || controllerOption === void 0 ? void 0 : controllerOption.routerOptions.description) || tag.name;
            }
            if (tag.name) {
                strTags.push(tag.name);
                this.documentBuilder.addTag(tag.name, tag.description);
            }
        }
        // const globalMiddleware = controllerOption.routerOptions.middleware;
        // get router info
        const webRouterInfo = (0, core_1.getClassMetadata)(core_1.WEB_ROUTER_KEY, target);
        let header = null;
        const headers = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_HEADERS);
        if (headers.length > 0) {
            header = headers[0].metadata;
        }
        const security = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_SECURITY);
        const paths = {};
        if (webRouterInfo && typeof webRouterInfo[Symbol.iterator] === 'function') {
            for (const webRouter of webRouterInfo) {
                let url = (prefix + webRouter.path).replace('//', '/');
                url = replaceUrl(url, parseParamsInPath(url));
                // 判断是否忽略当前路由
                const endpoints = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_EXCLUDE_ENDPOINT &&
                    item.propertyName === webRouter.method);
                if (endpoints[0]) {
                    continue;
                }
                const routerArgs = metaForParams[webRouter.method] || [];
                const bds = routerArgs.filter(item => {
                    var _a;
                    return item.key === core_1.WEB_ROUTER_PARAM_KEY &&
                        ((_a = item === null || item === void 0 ? void 0 : item.metadata) === null || _a === void 0 ? void 0 : _a.type) === core_1.RouteParamTypes.BODY;
                });
                if (bds.length > 1) {
                    // swagger not support more than one @Body
                    continue;
                }
                this.generateRouteMethod(url, webRouter, paths, metaForMethods, routerArgs, header, target);
                // 这里赋值 tags
                if (paths[url][webRouter.requestMethod].tags.length === 0) {
                    paths[url][webRouter.requestMethod].tags = strTags;
                }
                // extension => prefix 为 x-
                const exts = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_EXTENSION &&
                    item.propertyName === webRouter.method);
                for (const e of exts) {
                    if (e.metadata) {
                        Object.assign(paths[url][webRouter.requestMethod], e.metadata);
                    }
                }
                if (security.length > 0) {
                    if (!paths[url][webRouter.requestMethod].security) {
                        paths[url][webRouter.requestMethod].security = [];
                    }
                    for (const s of security) {
                        if (!s.metadata) {
                            continue;
                        }
                        paths[url][webRouter.requestMethod].security.push(s.metadata);
                    }
                }
            }
        }
        this.documentBuilder.addPaths(paths);
    }
    /**
     * 构造 router 提取方法
     */
    generateRouteMethod(url, webRouter, paths, metaForMethods, routerArgs, header, target) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const operMeta = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_OPERATION &&
            item.propertyName === webRouter.method)[0];
        let opts = paths[url];
        if (!opts) {
            opts = {};
        }
        const parameters = [];
        opts[webRouter.requestMethod] = {
            summary: getNotEmptyValue((_a = operMeta === null || operMeta === void 0 ? void 0 : operMeta.metadata) === null || _a === void 0 ? void 0 : _a.summary, webRouter.summary),
            description: getNotEmptyValue((_b = operMeta === null || operMeta === void 0 ? void 0 : operMeta.metadata) === null || _b === void 0 ? void 0 : _b.description, webRouter.description),
            // operationId: `${webRouter.requestMethod}_${(operMeta?.metadata?.operationId || webRouter.method)}`,
            tags: ((_c = operMeta === null || operMeta === void 0 ? void 0 : operMeta.metadata) === null || _c === void 0 ? void 0 : _c.tags) || [],
        };
        /**
         * [{"key":"web:router_param","parameterIndex":1,"propertyName":"create","metadata":{"type":2}},
         * {"key":"web:router_param","parameterIndex":0,"propertyName":"create","metadata":{"type":1,"propertyData":"createCatDto"}}]
         */
        // WEB_ROUTER_PARAM_KEY
        const args = routerArgs.filter(item => item.key === core_1.WEB_ROUTER_PARAM_KEY);
        const types = (0, core_1.getMethodParamTypes)(target, webRouter.method);
        const params = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_PARAMETERS &&
            item.propertyName === webRouter.method);
        for (const arg of args) {
            const currentType = types[arg.parameterIndex];
            const p = {
                name: (_e = (_d = arg === null || arg === void 0 ? void 0 : arg.metadata) === null || _d === void 0 ? void 0 : _d.propertyData) !== null && _e !== void 0 ? _e : '',
                in: convertTypeToString((_f = arg.metadata) === null || _f === void 0 ? void 0 : _f.type),
                required: false,
            };
            if (p.in === 'path') {
                p.required = true;
                if (url.indexOf('{' + p.name + '}') === -1) {
                    continue;
                }
            }
            if (core_1.Types.isClass(currentType)) {
                this.parseClzz(currentType);
                if (p.in === 'query') {
                    // 如果@Query()装饰的 是一个对象，则把该对象的子属性作为多个@Query参数
                    const schema = this.documentBuilder.getSchema(currentType.name);
                    Object.keys(schema.properties).forEach(pName => {
                        const ppt = schema.properties[pName];
                        const pp = {
                            name: pName,
                            in: p.in,
                        };
                        this.parseFromParamsToP({ metadata: ppt }, pp);
                        parameters.push(pp);
                    });
                    continue;
                }
                else {
                    p.schema = {
                        $ref: '#/components/schemas/' + currentType.name,
                    };
                }
            }
            else {
                p.schema = {
                    type: convertSchemaType((_g = currentType === null || currentType === void 0 ? void 0 : currentType.name) !== null && _g !== void 0 ? _g : currentType),
                };
            }
            this.parseFromParamsToP(params[params.length - 1 - arg.parameterIndex], p);
            if (p.in === 'body') {
                if (webRouter.requestMethod === core_1.RequestMethod.GET) {
                    continue;
                }
                // 这里兼容一下 @File()、@Files()、@Fields() 装饰器
                if (((_h = arg.metadata) === null || _h === void 0 ? void 0 : _h.type) === core_1.RouteParamTypes.FILESSTREAM) {
                    p.schema = {
                        type: 'object',
                        properties: {
                            files: {
                                type: 'array',
                                items: {
                                    type: 'string',
                                    format: 'binary',
                                },
                                description: p.description,
                            },
                        },
                    };
                    p.contentType = _1.BodyContentType.Multipart;
                }
                if (((_j = arg.metadata) === null || _j === void 0 ? void 0 : _j.type) === core_1.RouteParamTypes.FILESTREAM) {
                    p.schema = {
                        type: 'object',
                        properties: {
                            file: {
                                type: 'string',
                                format: 'binary',
                                description: p.description,
                            },
                        },
                    };
                    p.contentType = _1.BodyContentType.Multipart;
                }
                if (((_k = arg.metadata) === null || _k === void 0 ? void 0 : _k.type) === core_1.RouteParamTypes.FIELDS) {
                    this.expandSchemaRef(p);
                    p.contentType = _1.BodyContentType.Multipart;
                }
                if (!p.content) {
                    p.content = {};
                    p.content[p.contentType || 'application/json'] = {
                        schema: p.schema,
                    };
                }
                if (!opts[webRouter.requestMethod].requestBody) {
                    const requestBody = {
                        required: true,
                        description: p.description || p.name,
                        content: p.content,
                    };
                    opts[webRouter.requestMethod].requestBody = requestBody;
                }
                else {
                    // 这里拼 schema properties 时肯定存在
                    Object.assign(opts[webRouter.requestMethod].requestBody.content[p.contentType]
                        .schema.properties, p.schema.properties);
                }
                delete p.contentType;
                delete p.content;
                // in body 不需要处理
                continue;
            }
            parameters.push(p);
        }
        // class header 需要使用 ApiHeader 装饰器
        if (header) {
            parameters.unshift(header);
        }
        opts[webRouter.requestMethod].parameters = parameters;
        const responses = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_RESPONSE &&
            item.propertyName === webRouter.method);
        const returnResponses = {};
        for (const r of responses) {
            const resp = r.metadata;
            const keys = Object.keys(resp);
            for (const k of keys) {
                // 这里是引用，赋值可以直接更改
                const tt = resp[k];
                if (tt.type) {
                    if (core_1.Types.isClass(tt.type)) {
                        this.parseClzz(tt.type);
                        if (tt.isArray) {
                            tt.content = {
                                'application/json': {
                                    schema: {
                                        type: 'array',
                                        items: {
                                            $ref: '#/components/schemas/' + tt.type.name,
                                        },
                                    },
                                },
                            };
                        }
                        else {
                            tt.content = {
                                'application/json': {
                                    schema: {
                                        $ref: '#/components/schemas/' + tt.type.name,
                                    },
                                },
                            };
                        }
                    }
                    else {
                        tt.content = {
                            'text/plan': {
                                schema: {
                                    type: convertSchemaType(tt.type),
                                },
                            },
                        };
                    }
                }
                delete tt.status;
                delete tt.type;
                delete tt.isArray;
                delete tt.format;
            }
            Object.assign(returnResponses, resp);
        }
        if (Object.keys(returnResponses).length > 0) {
            opts[webRouter.requestMethod].responses = returnResponses;
        }
        else {
            opts[webRouter.requestMethod].responses = {
                200: {
                    description: 'OK',
                },
            };
        }
        paths[url] = opts;
    }
    expandSchemaRef(p, name) {
        let schemaName = name;
        if (p.schema['$ref']) {
            // 展开各个字段属性
            schemaName = p.schema['$ref'].replace('#/components/schemas/', '');
            delete p.schema['$ref'];
        }
        const schema = this.documentBuilder.getSchema(schemaName);
        const ss = JSON.parse(JSON.stringify(schema));
        if (p.schema.properties) {
            Object.assign(p.schema.properties, ss.properties);
        }
        else {
            p.schema = JSON.parse(JSON.stringify(schema));
        }
        return p;
    }
    /**
     * 提取参数
     * @param params
     * @param p
     */
    parseFromParamsToP(paramMeta, p) {
        var _a, _b, _c;
        if (paramMeta) {
            const param = paramMeta.metadata;
            if (param) {
                p.description = param.description;
                if (!p.name && param.name) {
                    p.name = param.name;
                }
                if (param.in === 'query') {
                    p.allowEmptyValue = param.allowEmptyValue || false;
                }
                if (typeof param.example !== undefined) {
                    p.example = param.example;
                }
                if (param.examples) {
                    p.examples = param.examples;
                }
                if (param.deprecated) {
                    p.deprecated = param.deprecated;
                }
                if (param.contentType) {
                    p.contentType = param.contentType;
                }
                p.in = (_a = param === null || param === void 0 ? void 0 : param.in) !== null && _a !== void 0 ? _a : p.in;
                p.required = (_b = param === null || param === void 0 ? void 0 : param.required) !== null && _b !== void 0 ? _b : p.required;
                if (p.in === 'query') {
                    p.style = 'form';
                }
                else if (p.in === 'path' || p.in === 'header') {
                    p.style = 'simple';
                }
                else if (p.in === 'cookie') {
                    p.style = 'form';
                }
                p.explode = p.style === 'form';
                // response content
                if (param === null || param === void 0 ? void 0 : param.content) {
                    p.content = param === null || param === void 0 ? void 0 : param.content;
                }
                if (param.schema) {
                    p.schema = param.schema;
                }
                else {
                    if (param.type) {
                        if (core_1.Types.isClass(param.type)) {
                            this.parseClzz(param.type);
                            p.schema = {
                                $ref: '#/components/schemas/' + param.type.name,
                            };
                        }
                        if (param.isArray) {
                            let ref;
                            if ((_c = p === null || p === void 0 ? void 0 : p.schema) === null || _c === void 0 ? void 0 : _c.$ref) {
                                ref = p.schema.$ref;
                            }
                            p.schema = {
                                type: 'array',
                                items: {
                                    format: param.format,
                                },
                            };
                            if (ref) {
                                p.schema.items.$ref = ref;
                            }
                            else {
                                p.schema.items.type = convertSchemaType(param.type);
                            }
                        }
                        else {
                            if (!p.schema) {
                                p.schema = {
                                    type: param.type ? convertSchemaType(param.type) : p.type,
                                    format: param.format || p.format,
                                };
                            }
                        }
                    }
                    else if (param.format) {
                        p.schema.format = param.format;
                    }
                }
            }
        }
    }
    /**
     * 解析 ApiExtraModel
     * @param clzz
     */
    parseExtraModel(clzz) {
        const metaForMethods = (0, core_1.getClassMetadata)(core_1.INJECT_CUSTOM_METHOD, clzz) || [];
        const extraModels = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_EXTRA_MODEL);
        for (const m of extraModels) {
            if (Array.isArray(m.metadata)) {
                for (const sclz of m.metadata) {
                    this.parseClzz(sclz);
                }
            }
            else {
                this.parseClzz(m.metadata);
            }
        }
    }
    parseSubPropertyType(metadata) {
        var _a, _b, _c;
        let typeMeta;
        if (metadata === null || metadata === void 0 ? void 0 : metadata.enum) {
            typeMeta = {
                type: metadata === null || metadata === void 0 ? void 0 : metadata.type,
                enum: metadata === null || metadata === void 0 ? void 0 : metadata.enum,
                default: metadata === null || metadata === void 0 ? void 0 : metadata.default,
            };
            if (metadata === null || metadata === void 0 ? void 0 : metadata.description) {
                typeMeta.description = metadata === null || metadata === void 0 ? void 0 : metadata.description;
            }
            return typeMeta;
        }
        if ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.items) === null || _a === void 0 ? void 0 : _a.enum) {
            typeMeta = {
                type: metadata === null || metadata === void 0 ? void 0 : metadata.type,
                items: metadata === null || metadata === void 0 ? void 0 : metadata.items,
                default: metadata === null || metadata === void 0 ? void 0 : metadata.default,
            };
            if (metadata === null || metadata === void 0 ? void 0 : metadata.description) {
                typeMeta.description = metadata === null || metadata === void 0 ? void 0 : metadata.description;
            }
            return typeMeta;
        }
        let isArray = false;
        let currentType = parseTypeSchema(metadata === null || metadata === void 0 ? void 0 : metadata.type);
        metadata === null || metadata === void 0 ? true : delete metadata.type;
        if (currentType === 'array') {
            isArray = true;
            currentType = parseTypeSchema((_b = metadata === null || metadata === void 0 ? void 0 : metadata.items) === null || _b === void 0 ? void 0 : _b.type);
            metadata === null || metadata === void 0 ? true : delete metadata.items.type;
        }
        if (metadata === null || metadata === void 0 ? void 0 : metadata.oneOf) {
            typeMeta = {
                oneOf: [],
            };
            metadata === null || metadata === void 0 ? void 0 : metadata.oneOf.forEach((item) => {
                typeMeta.push(this.parseSubPropertyType(item));
            });
            metadata === null || metadata === void 0 ? true : delete metadata.oneOf;
        }
        if (core_1.Types.isClass(currentType)) {
            this.parseClzz(currentType);
            if (isArray) {
                typeMeta = {
                    type: 'array',
                    items: {
                        $ref: '#/components/schemas/' + (currentType === null || currentType === void 0 ? void 0 : currentType.name),
                    },
                };
            }
            else {
                typeMeta = {
                    $ref: '#/components/schemas/' + (currentType === null || currentType === void 0 ? void 0 : currentType.name),
                };
            }
            delete metadata.items;
        }
        else {
            if (isArray) {
                // 没有配置类型则认为自己配置了 items 内容
                if (!currentType) {
                    if ((_c = metadata === null || metadata === void 0 ? void 0 : metadata.items) === null || _c === void 0 ? void 0 : _c['$ref']) {
                        metadata.items['$ref'] = parseTypeSchema(metadata.items['$ref']);
                    }
                    typeMeta = {
                        type: 'array',
                        items: metadata === null || metadata === void 0 ? void 0 : metadata.items,
                    };
                }
                else {
                    typeMeta = {
                        type: 'array',
                        items: {
                            type: convertSchemaType((currentType === null || currentType === void 0 ? void 0 : currentType.name) || currentType),
                        },
                    };
                }
                delete metadata.items;
            }
            else {
                typeMeta = {
                    type: currentType,
                    format: metadata === null || metadata === void 0 ? void 0 : metadata.format,
                };
                // Date 类型支持
                if (typeMeta.type === 'Date') {
                    typeMeta.type = 'string';
                    if (!typeMeta.format) {
                        typeMeta.format = 'date';
                    }
                }
                delete metadata.format;
            }
        }
        return Object.assign(typeMeta, metadata);
    }
    /**
     * 解析类型的 ApiProperty
     * @param clzz
     */
    parseClzz(clzz) {
        if (this.documentBuilder.getSchema(clzz.name)) {
            return this.documentBuilder.getSchema(clzz.name);
        }
        this.parseExtraModel(clzz);
        const props = (0, core_1.getClassExtendedMetadata)(core_1.INJECT_CUSTOM_PROPERTY, clzz);
        const tt = {
            type: 'object',
            properties: {},
        };
        if (props) {
            Object.keys(props).forEach(key => {
                var _a, _b, _c;
                const metadata = props[key].metadata;
                if (typeof (metadata === null || metadata === void 0 ? void 0 : metadata.required) !== undefined) {
                    if (metadata === null || metadata === void 0 ? void 0 : metadata.required) {
                        if (!tt.required) {
                            tt.required = [];
                        }
                        tt.required.push(key);
                    }
                    delete metadata.required;
                }
                if (metadata === null || metadata === void 0 ? void 0 : metadata.enum) {
                    tt.properties[key] = {
                        type: metadata === null || metadata === void 0 ? void 0 : metadata.type,
                        enum: metadata === null || metadata === void 0 ? void 0 : metadata.enum,
                        default: metadata === null || metadata === void 0 ? void 0 : metadata.default,
                    };
                    if (metadata === null || metadata === void 0 ? void 0 : metadata.description) {
                        tt.properties[key].description = metadata === null || metadata === void 0 ? void 0 : metadata.description;
                    }
                    return;
                }
                if ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.items) === null || _a === void 0 ? void 0 : _a.enum) {
                    tt.properties[key] = {
                        type: metadata === null || metadata === void 0 ? void 0 : metadata.type,
                        items: metadata === null || metadata === void 0 ? void 0 : metadata.items,
                        default: metadata === null || metadata === void 0 ? void 0 : metadata.default,
                    };
                    if (metadata === null || metadata === void 0 ? void 0 : metadata.description) {
                        tt.properties[key].description = metadata === null || metadata === void 0 ? void 0 : metadata.description;
                    }
                    return;
                }
                let isArray = false;
                let currentType = parseTypeSchema(metadata === null || metadata === void 0 ? void 0 : metadata.type);
                metadata === null || metadata === void 0 ? true : delete metadata.type;
                if (currentType === 'array') {
                    isArray = true;
                    currentType = parseTypeSchema((_b = metadata === null || metadata === void 0 ? void 0 : metadata.items) === null || _b === void 0 ? void 0 : _b.type);
                    metadata === null || metadata === void 0 ? true : delete metadata.items.type;
                }
                if (metadata === null || metadata === void 0 ? void 0 : metadata.oneOf) {
                    tt.properties[key] = {
                        oneOf: [],
                    };
                    metadata === null || metadata === void 0 ? void 0 : metadata.oneOf.forEach((meta) => {
                        tt.properties[key].oneOf.push(this.parseSubPropertyType(meta));
                    });
                    metadata === null || metadata === void 0 ? true : delete metadata.oneOf;
                    return;
                }
                if (core_1.Types.isClass(currentType)) {
                    this.parseClzz(currentType);
                    if (isArray) {
                        tt.properties[key] = {
                            type: 'array',
                            items: {
                                $ref: '#/components/schemas/' + (currentType === null || currentType === void 0 ? void 0 : currentType.name),
                            },
                        };
                    }
                    else {
                        tt.properties[key] = {
                            $ref: '#/components/schemas/' + (currentType === null || currentType === void 0 ? void 0 : currentType.name),
                        };
                    }
                    delete metadata.items;
                }
                else {
                    if (isArray) {
                        // 没有配置类型则认为自己配置了 items 内容
                        if (!currentType) {
                            if ((_c = metadata === null || metadata === void 0 ? void 0 : metadata.items) === null || _c === void 0 ? void 0 : _c['$ref']) {
                                metadata.items['$ref'] = parseTypeSchema(metadata.items['$ref']);
                            }
                            tt.properties[key] = {
                                type: 'array',
                                items: metadata === null || metadata === void 0 ? void 0 : metadata.items,
                            };
                        }
                        else {
                            tt.properties[key] = {
                                type: 'array',
                                items: {
                                    type: convertSchemaType((currentType === null || currentType === void 0 ? void 0 : currentType.name) || currentType),
                                },
                            };
                        }
                        delete metadata.items;
                    }
                    else {
                        tt.properties[key] = {
                            type: currentType !== null && currentType !== void 0 ? currentType : (0, core_1.getPropertyType)(clzz.prototype, key).name,
                            format: metadata === null || metadata === void 0 ? void 0 : metadata.format,
                        };
                        // Date 类型支持
                        if (tt.properties[key].type === 'Date') {
                            tt.properties[key].type = 'string';
                            if (!tt.properties[key].format) {
                                tt.properties[key].format = 'date';
                            }
                        }
                        delete metadata.format;
                    }
                }
                Object.assign(tt.properties[key], metadata);
            });
        }
        this.documentBuilder.addSchema({
            [clzz.name]: tt,
        });
        // just for test
        return tt;
    }
    /**
     * 授权验证
     * @param opts
     * @returns
     */
    setAuth(opts) {
        if (!opts) {
            return;
        }
        const authType = opts.authType;
        delete opts.authType;
        // TODO 加 security
        switch (authType) {
            case 'basic':
                {
                    const name = opts.name;
                    delete opts.name;
                    this.documentBuilder.addBasicAuth(opts, name);
                }
                break;
            case 'bearer':
                {
                    const name = opts.name;
                    delete opts.name;
                    this.documentBuilder.addBearerAuth(opts, name);
                }
                break;
            case 'cookie':
                {
                    const cname = opts.cookieName;
                    const secName = opts.securityName;
                    delete opts.cookieName;
                    delete opts.securityName;
                    this.documentBuilder.addCookieAuth(cname, opts, secName);
                }
                break;
            case 'oauth2':
                {
                    const name = opts.name;
                    delete opts.name;
                    this.documentBuilder.addOAuth2(opts, name);
                }
                break;
            case 'apikey':
                {
                    const name = opts.name;
                    delete opts.name;
                    this.documentBuilder.addApiKey(opts, name);
                }
                break;
            case 'custom':
                {
                    this.documentBuilder.addSecurity(opts === null || opts === void 0 ? void 0 : opts.name, opts);
                }
                break;
        }
    }
};
__decorate([
    (0, core_1.Config)('swagger'),
    __metadata("design:type", Object)
], SwaggerExplorer.prototype, "swaggerConfig", void 0);
__decorate([
    (0, core_1.Init)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SwaggerExplorer.prototype, "init", null);
SwaggerExplorer = __decorate([
    (0, core_1.Provide)(),
    (0, core_1.Scope)(core_1.ScopeEnum.Singleton)
], SwaggerExplorer);
exports.SwaggerExplorer = SwaggerExplorer;
/**
 * 解释路由上的参数
 * @param url
 */
function parseParamsInPath(url) {
    const names = [];
    url.split('/').forEach(item => {
        if (item.startsWith(':')) {
            const paramName = item.slice(1);
            names.push(paramName);
        }
    });
    return names;
}
/**
 * 替换成 openapi 的url
 * @param url
 * @param names
 */
function replaceUrl(url, names) {
    names.forEach(n => {
        url = url.replace(`:${n}`, `{${n}}`);
    });
    return url;
}
function convertTypeToString(type) {
    switch (type) {
        case core_1.RouteParamTypes.HEADERS:
            return 'header';
        case core_1.RouteParamTypes.QUERY:
            return 'query';
        case core_1.RouteParamTypes.PARAM:
            return 'path';
        case core_1.RouteParamTypes.BODY:
        case core_1.RouteParamTypes.FIELDS:
        case core_1.RouteParamTypes.FILESSTREAM:
        case core_1.RouteParamTypes.FILESTREAM:
            return 'body';
        default:
            return 'header';
    }
}
function convertSchemaType(value) {
    switch (value) {
        case 'Object':
            return 'object';
        case 'Boolean':
            return 'boolean';
        case 'Number':
            return 'number';
        case 'String':
            return 'string';
        default:
            return value;
    }
}
function getNotEmptyValue(...args) {
    for (const arg of args) {
        if (arg) {
            return arg;
        }
    }
}
function parseTypeSchema(ref) {
    switch (ref) {
        case String:
            return 'string';
        case Number:
            return 'number';
        case Boolean:
            return 'boolean';
        default:
            if (typeof ref === 'function' && !core_1.Types.isClass(ref)) {
                ref = ref();
            }
            return ref;
    }
}
//# sourceMappingURL=swaggerExplorer.js.map